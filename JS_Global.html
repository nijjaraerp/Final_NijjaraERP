<script>
/* ============================================
   NIJJARA ERP - GLOBAL CLIENT-SIDE UTILITIES
   Error Handling | Logging | Toast System | Loading Indicators
   ============================================ */

// ----------------------------------------
// GLOBAL ERROR HANDLER
// ----------------------------------------
function handleClientError(error, functionName = 'UNKNOWN_CLIENT_FUNCTION', context = {}) {
  const safeError = error instanceof Error
    ? error
    : new Error(typeof error === 'string' ? error : 'Unknown client error');

  // Sanitize context to avoid circular references
  const sanitizedContext = {};
  if (context && typeof context === 'object') {
    Object.keys(context).forEach((key) => {
      const value = context[key];
      if (value === null || typeof value === 'undefined') {
        sanitizedContext[key] = value;
      } else if (typeof value === 'object') {
        try {
          sanitizedContext[key] = JSON.parse(JSON.stringify(value));
        } catch (serializationError) {
          sanitizedContext[key] = value.toString ? value.toString() : '[object Object]';
        }
      } else {
        sanitizedContext[key] = value;
      }
    });
  }

  const errorPayload = {
    message: safeError.message,
    stack: safeError.stack || null,
    functionName,
    context: sanitizedContext,
    location: typeof window !== 'undefined' && window.location ? window.location.href : '',
    userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : '',
    timestamp: new Date().toISOString()
  };

  Logger.error('ClientError', `Client error in ${functionName}`, safeError);

  showToast(
    'حدث خطأ غير متوقع. يرجى تحديث الصفحة أو الاتصال بالدعم الفني.',
    'error'
  );

  if (typeof google === 'undefined' || !google.script || !google.script.run) {
    Logger.warn('ClientError', 'google.script.run unavailable; skipping server logging');
    return false;
  }

  try {
    google.script.run
      .withFailureHandler((serverError) => {
        Logger.error('ClientError', 'Failed to forward client error to server', serverError);
      })
      .logError_(
        `CLIENT_SIDE: ${functionName}`,
        JSON.stringify(errorPayload),
        errorPayload.stack || errorPayload.message
      );
  } catch (forwardError) {
    Logger.error('ClientError', 'Exception while forwarding client error to server', forwardError);
  }

  return false;
}

window.onerror = function(message, source, lineno, colno, error) {
  const context = {
    source: source,
    line: lineno,
    column: colno,
    originalMessage: message
  };
  const errorInstance = error instanceof Error ? error : new Error(message || 'Window error');
  return handleClientError(errorInstance, 'GLOBAL_WINDOW_ONERROR', context);
};

window.addEventListener('unhandledrejection', (event) => {
  if (event && typeof event.preventDefault === 'function') {
    event.preventDefault();
  }
  const reason = event && event.reason;
  const errorInstance = reason instanceof Error
    ? reason
    : new Error(typeof reason === 'string' ? reason : 'Unhandled promise rejection');
  handleClientError(errorInstance, 'GLOBAL_UNHANDLED_REJECTION', {
    reason: reason && reason.toString ? reason.toString() : String(reason)
  });
});

// ----------------------------------------
// LOGGING UTILITIES
// ----------------------------------------
const Logger = {
  /**
   * Log info message to console
   * @param {string} context - The context/module name
   * @param {string} message - The log message
   * @param {*} data - Optional additional data
   */
  info: function(context, message, data = null) {
    console.log(`[INFO] ${context}:`, message, data || '');
  },
  
  /**
   * Log warning message to console
   * @param {string} context - The context/module name
   * @param {string} message - The log message
   * @param {*} data - Optional additional data
   */
  warn: function(context, message, data = null) {
    console.warn(`[WARN] ${context}:`, message, data || '');
  },
  
  /**
   * Log error message to console
   * @param {string} context - The context/module name
   * @param {string} message - The log message
   * @param {Error} error - The error object
   */
  error: function(context, message, error = null) {
    console.error(`[ERROR] ${context}:`, message, error || '');
  },
  
  /**
   * Log debug message to console (only in development)
   * @param {string} context - The context/module name
   * @param {string} message - The log message
   * @param {*} data - Optional additional data
   */
  debug: function(context, message, data = null) {
    if (window.location.hostname === 'localhost' || window.location.hostname.includes('script.google')) {
      console.debug(`[DEBUG] ${context}:`, message, data || '');
    }
  }
};

// ----------------------------------------
// TOAST NOTIFICATION SYSTEM
// ----------------------------------------
const Toast = {
  /**
   * Show a toast notification
   * @param {string} message - The message to display
   * @param {string} type - Type: 'success', 'error', 'warning', 'info'
   * @param {number} duration - Duration in milliseconds (default: 5000)
   */
  show: function(message, type = 'info', duration = 5000) {
    const container = document.getElementById('toast-container');
    if (!container) {
      Logger.error('Toast', 'Toast container not found');
      return;
    }
    
    // Create toast element
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.setAttribute('role', 'alert');
    toast.setAttribute('aria-live', 'polite');
    
    // Set icon based on type
    let icon = 'info';
    if (type === 'success') icon = 'check_circle';
    else if (type === 'error') icon = 'error';
    else if (type === 'warning') icon = 'warning';
    
    toast.innerHTML = `
      <span class="material-icons toast-icon">${icon}</span>
      <div class="toast-content">${message}</div>
      <button class="toast-close" onclick="this.parentElement.remove()" aria-label="إغلاق">
        <span class="material-icons">close</span>
      </button>
    `;
    
    container.appendChild(toast);
    
    // Auto-remove after duration
    if (duration > 0) {
      setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => toast.remove(), 300);
      }, duration);
    }
    
    Logger.debug('Toast', `Displayed ${type} toast: ${message}`);
  }
};

// Convenience wrapper function
function showToast(message, type = 'info', duration = 5000) {
  Toast.show(message, type, duration);
}

// ----------------------------------------
// LOADING INDICATORS
// ----------------------------------------
const Loading = {
  /**
   * Show the global loading screen
   * @param {string} message - Optional loading message
   */
  show: function(message = 'جاري التحميل...') {
    const loadingScreen = document.getElementById('loading-screen');
    if (loadingScreen) {
      const textElement = loadingScreen.querySelector('.loading-text');
      if (textElement) {
        textElement.textContent = message;
      }
      loadingScreen.classList.remove('hidden');
      Logger.debug('Loading', 'Loading screen shown');
    }
  },
  
  /**
   * Hide the global loading screen
   */
  hide: function() {
    const loadingScreen = document.getElementById('loading-screen');
    if (loadingScreen) {
      loadingScreen.classList.add('hidden');
      Logger.debug('Loading', 'Loading screen hidden');
    }
  },
  
  /**
   * Show button loading state
   * @param {HTMLButtonElement} button - The button element
   * @param {string} originalText - Optional original button text to restore later
   */
  buttonStart: function(button, originalText = null) {
    if (!button) return;
    
    if (originalText) {
      button.setAttribute('data-original-text', originalText);
    }
    
    button.disabled = true;
    button.innerHTML = '<span class="btn-loader"><span class="spinner"></span></span>';
    Logger.debug('Loading', 'Button loading started');
  },
  
  /**
   * Hide button loading state
   * @param {HTMLButtonElement} button - The button element
   * @param {string} text - Optional text to set (uses data-original-text if not provided)
   */
  buttonEnd: function(button, text = null) {
    if (!button) return;
    
    button.disabled = false;
    const originalText = text || button.getAttribute('data-original-text') || 'تم';
    button.innerHTML = originalText;
    button.removeAttribute('data-original-text');
    Logger.debug('Loading', 'Button loading ended');
  }
};

// Convenience wrapper functions
function showLoading(message) {
  Loading.show(message);
}

function hideLoading() {
  Loading.hide();
}

// ----------------------------------------
// UTILITY FUNCTIONS
// ----------------------------------------
const Utils = {
  /**
   * Safely parse JSON with error handling
   * @param {string} jsonString - The JSON string to parse
   * @param {*} defaultValue - Default value if parsing fails
   * @returns {*} Parsed object or default value
   */
  safeJSONParse: function(jsonString, defaultValue = null) {
    try {
      return JSON.parse(jsonString);
    } catch (error) {
      Logger.error('Utils', 'JSON parse error', error);
      return defaultValue;
    }
  },
  
  /**
   * Get value from localStorage with error handling
   * @param {string} key - The storage key
   * @param {*} defaultValue - Default value if key doesn't exist
   * @returns {*} The stored value or default
   */
  getStorage: function(key, defaultValue = null) {
    try {
      const value = localStorage.getItem(key);
      return value ? this.safeJSONParse(value, defaultValue) : defaultValue;
    } catch (error) {
      Logger.error('Utils', 'localStorage get error', error);
      return defaultValue;
    }
  },
  
  /**
   * Set value in localStorage with error handling
   * @param {string} key - The storage key
   * @param {*} value - The value to store
   * @returns {boolean} Success status
   */
  setStorage: function(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch (error) {
      Logger.error('Utils', 'localStorage set error', error);
      showToast('فشل حفظ البيانات محلياً', 'warning');
      return false;
    }
  },
  
  /**
   * Remove value from localStorage
   * @param {string} key - The storage key
   */
  removeStorage: function(key) {
    try {
      localStorage.removeItem(key);
    } catch (error) {
      Logger.error('Utils', 'localStorage remove error', error);
    }
  },
  
  /**
   * Clear all localStorage
   */
  clearStorage: function() {
    try {
      localStorage.clear();
      Logger.info('Utils', 'localStorage cleared');
    } catch (error) {
      Logger.error('Utils', 'localStorage clear error', error);
    }
  },
  
  /**
   * Debounce function execution
   * @param {Function} func - The function to debounce
   * @param {number} wait - Wait time in milliseconds
   * @returns {Function} Debounced function
   */
  debounce: function(func, wait = 300) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  },
  
  /**
   * Sanitize HTML to prevent XSS
   * @param {string} str - The string to sanitize
   * @returns {string} Sanitized string
   */
  escapeHtml: function(str) {
    if (!str) return '';
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  },
  
  /**
   * Format date to Arabic locale
   * @param {Date|string} date - The date to format
   * @param {string} format - Format type: 'short', 'long', 'time'
   * @returns {string} Formatted date string
   */
  formatDate: function(date, format = 'short') {
    if (!date) return '';
    
    const d = typeof date === 'string' ? new Date(date) : date;
    
    if (isNaN(d.getTime())) {
      Logger.error('Utils', 'Invalid date', date);
      return '';
    }
    
    const options = {
      short: { year: 'numeric', month: 'numeric', day: 'numeric' },
      long: { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' },
      time: { hour: '2-digit', minute: '2-digit', hour12: true }
    };
    
    return d.toLocaleString('ar-SA', options[format] || options.short);
  },
  
  /**
   * Validate email format
   * @param {string} email - Email to validate
   * @returns {boolean} True if valid
   */
  isValidEmail: function(email) {
    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return re.test(email);
  },
  
  /**
   * Generate random ID
   * @param {number} length - Length of ID
   * @returns {string} Random ID
   */
  generateId: function(length = 8) {
    return Math.random().toString(36).substring(2, length + 2);
  },
  
  /**
   * Copy text to clipboard
   * @param {string} text - Text to copy
   * @returns {Promise<boolean>} Success status
   */
  copyToClipboard: async function(text) {
    try {
      await navigator.clipboard.writeText(text);
      showToast('تم النسخ إلى الحافظة', 'success', 2000);
      return true;
    } catch (error) {
      Logger.error('Utils', 'Clipboard copy failed', error);
      showToast('فشل النسخ إلى الحافظة', 'error');
      return false;
    }
  },
  
  /**
   * Show/hide element with transition
   * @param {HTMLElement} element - Element to toggle
   * @param {boolean} show - Show or hide
   */
  toggleElement: function(element, show) {
    if (!element) return;
    
    if (show) {
      element.classList.remove('hidden');
      // Trigger reflow to enable CSS transition
      element.offsetHeight;
      element.style.opacity = '1';
    } else {
      element.style.opacity = '0';
      setTimeout(() => element.classList.add('hidden'), 300);
    }
  }
};

// ----------------------------------------
// FORM VALIDATION HELPERS
// ----------------------------------------
const FormValidator = {
  /**
   * Validate required field
   * @param {HTMLInputElement} input - Input element
   * @returns {boolean} Valid status
   */
  validateRequired: function(input) {
    const value = input.value.trim();
    const errorElement = input.parentElement.querySelector('.error-message');
    
    if (!value) {
      if (errorElement) {
        errorElement.textContent = 'هذا الحقل مطلوب';
      }
      input.classList.add('error');
      return false;
    }
    
    if (errorElement) {
      errorElement.textContent = '';
    }
    input.classList.remove('error');
    return true;
  },
  
  /**
   * Validate email field
   * @param {HTMLInputElement} input - Input element
   * @returns {boolean} Valid status
   */
  validateEmail: function(input) {
    const value = input.value.trim();
    const errorElement = input.parentElement.querySelector('.error-message');
    
    if (!value) {
      if (errorElement) {
        errorElement.textContent = 'هذا الحقل مطلوب';
      }
      input.classList.add('error');
      return false;
    }
    
    if (!Utils.isValidEmail(value)) {
      if (errorElement) {
        errorElement.textContent = 'البريد الإلكتروني غير صحيح';
      }
      input.classList.add('error');
      return false;
    }
    
    if (errorElement) {
      errorElement.textContent = '';
    }
    input.classList.remove('error');
    return true;
  },
  
  /**
   * Clear form errors
   * @param {HTMLFormElement} form - Form element
   */
  clearErrors: function(form) {
    if (!form) return;
    
    const errorElements = form.querySelectorAll('.error-message');
    errorElements.forEach(el => el.textContent = '');
    
    const inputsWithErrors = form.querySelectorAll('.error');
    inputsWithErrors.forEach(input => input.classList.remove('error'));
  }
};

// ----------------------------------------
// SESSION MANAGEMENT
// ----------------------------------------
const Session = {
  STORAGE_KEY: 'session',

  /**
   * Safely parse stored JSON
   * @param {string} value
   * @param {*} defaultValue
   * @returns {*}
   */
  _parse: function(value, defaultValue = null) {
    if (!value) {
      return defaultValue;
    }
    try {
      return JSON.parse(value);
    } catch (error) {
      Logger.error('Session', 'Storage parse error', error);
      return defaultValue;
    }
  },

  /**
   * Read session data from provided storage
   * @param {Storage} storage
   * @returns {Object|null}
   */
  _readFromStorage: function(storage) {
    if (!storage) {
      return null;
    }
    try {
      const raw = storage.getItem(this.STORAGE_KEY);
      return this._parse(raw, null);
    } catch (error) {
      Logger.error('Session', 'Storage read error', error);
      return null;
    }
  },

  /**
   * Write session data to provided storage
   * @param {Storage} storage
   * @param {Object} data
   * @returns {boolean}
   */
  _writeToStorage: function(storage, data) {
    if (!storage) {
      return false;
    }
    try {
      storage.setItem(this.STORAGE_KEY, JSON.stringify(data));
      return true;
    } catch (error) {
      Logger.error('Session', 'Storage write error', error);
      showToast('تعذر حفظ بيانات الجلسة محلياً', 'warning');
      return false;
    }
  },

  /**
   * Remove session data from provided storage
   * @param {Storage} storage
   */
  _removeFromStorage: function(storage) {
    if (!storage) {
      return;
    }
    try {
      storage.removeItem(this.STORAGE_KEY);
    } catch (error) {
      Logger.error('Session', 'Storage remove error', error);
    }
  },

  /**
   * Get the stored session record and storage type
   * @returns {{data:Object, storage:string}|null}
   */
  _getStoredRecord: function() {
    const sessionStorageRef = (typeof window !== 'undefined' && window.sessionStorage) ? window.sessionStorage : null;
    const localStorageRef = (typeof window !== 'undefined' && window.localStorage) ? window.localStorage : null;
    const tempData = this._readFromStorage(sessionStorageRef);
    if (tempData) {
      return { data: tempData, storage: 'session' };
    }
    const persistentData = this._readFromStorage(localStorageRef);
    if (persistentData) {
      return { data: persistentData, storage: 'local' };
    }
    return null;
  },

  /**
   * Check if user has active session
   * @returns {boolean}
   */
  isActive: function() {
    const record = this._getStoredRecord();
    if (!record) {
      return false;
    }

    const { data, storage } = record;

    if (!data || !data.token || !data.timestamp) {
      this.clear();
      return false;
    }

    if (data.expiresAt) {
      const expiryTime = Date.parse(data.expiresAt);
      if (!Number.isNaN(expiryTime) && Date.now() > expiryTime) {
        Logger.info('Session', 'Session expired based on server timestamp');
        this.clear();
        return false;
      }
    }

    const sessionAge = Date.now() - data.timestamp;
    const maxAge = 24 * 60 * 60 * 1000; // 24 hours

    if (sessionAge > maxAge) {
      Logger.info('Session', 'Session expired');
      this.clear();
      return false;
    }

    // Legacy sessions (stored in localStorage without remember-me flag) should be cleared
    if (storage === 'local' && data.persistent !== true) {
      Logger.info('Session', 'Clearing legacy session without persistence flag');
      this.clear();
      return false;
    }

    return true;
  },

  /**
   * Get current session data
   * @returns {Object|null}
   */
  get: function() {
    const record = this._getStoredRecord();
    return record ? record.data : null;
  },

  /**
   * Set session data
   * @param {Object} data
   * @param {Object} options
   */
  set: function(data, options = {}) {
    const persistent = options.persistent === true;
    let expiresAt = null;
    if (data.expiresAt) {
      if (data.expiresAt instanceof Date) {
        expiresAt = data.expiresAt.toISOString();
      } else if (typeof data.expiresAt === 'number') {
        expiresAt = new Date(data.expiresAt).toISOString();
      } else if (typeof data.expiresAt === 'string') {
        const parsedExpiry = Date.parse(data.expiresAt);
        expiresAt = Number.isNaN(parsedExpiry) ? null : new Date(parsedExpiry).toISOString();
      }
    }

    const sessionData = {
      ...data,
      timestamp: Date.now(),
      persistent,
      expiresAt
    };

    const sessionStorageRef = (typeof window !== 'undefined' && window.sessionStorage) ? window.sessionStorage : null;
    const localStorageRef = (typeof window !== 'undefined' && window.localStorage) ? window.localStorage : null;

    if (persistent) {
      this._removeFromStorage(sessionStorageRef);
      if (this._writeToStorage(localStorageRef, sessionData)) {
        Logger.info('Session', 'Session created (persistent)');
      }
    } else {
      this._removeFromStorage(localStorageRef);
      if (this._writeToStorage(sessionStorageRef, sessionData)) {
        Logger.info('Session', 'Session created (temporary)');
      }
    }
  },

  /**
   * Clear session data
   */
  clear: function() {
    const sessionStorageRef = (typeof window !== 'undefined' && window.sessionStorage) ? window.sessionStorage : null;
    const localStorageRef = (typeof window !== 'undefined' && window.localStorage) ? window.localStorage : null;
    this._removeFromStorage(sessionStorageRef);
    this._removeFromStorage(localStorageRef);
    Logger.info('Session', 'Session cleared');
  },

  /**
   * Get current user from session
   * @returns {Object|null}
   */
  getUser: function() {
    const session = this.get();
    return session ? session.user : null;
  }
};

// ----------------------------------------
// INITIALIZATION
// ----------------------------------------
Logger.info('Global', 'Client-side utilities loaded');
</script>
